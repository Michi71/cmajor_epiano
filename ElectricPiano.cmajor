//
//     ,ad888ba,                              88
//    d8"'    "8b
//   d8            88,dba,,adba,   ,aPP8A.A8  88     (C)2024 Cmajor Software Ltd
//   Y8,           88    88    88  88     88  88
//    Y8a.   .a8P  88    88    88  88,   ,88  88     https://cmajor.dev
//     '"Y888Y"'   88    88    88  '"8bbP"Y8  88
//                                           ,88
//                                        888P"
//
//  This code may be used under either a GPLv3 or commercial
//  license: see LICENSE.md for more details.

graph ElectricPiano  [[ main ]]
{
    input event std::midi::Message midiIn  [[ name: "MIDI input" ]];
    input paramsProcessor.*;

    output stream float<2> audioOut  [[ name: "Audio Out" ]];

    node
    {
        voices          = Voice[64];
        voiceAllocator  = std::voices::VoiceAllocator(64);
        paramsProcessor = Instrument::ParamsProcessor;   

        pickup = PickupModel;
        hammer = HammerModel;
        fork   = ForkModel;
        damper = DamperModel;
        chorus = ChorusEffect;
        phaser = PhaserEffect;
        tremolo= Tremolo;
    }


    connection
    {
        midiIn -> std::midi::MPEConverter -> voiceAllocator -> voices.eventsIn, damper.eventsIn;

        paramsProcessor.paramsOut -> voices.paramsIn, pickup.paramsIn, 
                                     hammer.paramsIn, fork.paramsIn, damper.paramsIn, 
                                     chorus.paramsIn, phaser.paramsIn, tremolo.paramsIn;

        voices.audioOut -> pickup.in;
        pickup.out      -> hammer.in;
        hammer.out      -> fork.in;
        fork.out        -> damper.in;
        damper.out      -> chorus.in;
        chorus.out      -> phaser.in;
        phaser.out      -> tremolo.in;
        tremolo.out     -> audioOut;

        // Damper bekommt Note-Events
        midiIn -> std::midi::MPEConverter -> damper.eventsIn;
    }
}

//==============================================================================
namespace Instrument
{
    let harmonics = 32;

    struct Params
    {
        float brightness;
        float velocityScaling;
        float decayRate;
        float harmonicDecayRate;
        float keyScaling;
        float releaseRate;

        // Vibrato
        float vibratoDepth;
        float vibratoRate;

        // Pickup
        int pickupType;
        float pickupSymmetry;
        float pickupDistance;
        float pickupInputGain;
        float pickupOutputGain;
        float pickupNonlinearity;
        float pickupBarkAmount;

        // Hammer
        float hammerStiffness;
        float hammerStrength;
        float hammerNoise;

        // Fork
        float forkDecay;
        float forkVolume;
        float forkToneColor;
        float forkRingTime;
        float forkResonance;

        // Damper
        float damperTone;
        float damperAttack;
        float damperRelease;
        float damperLevel;

        // Chorus
        float chorusDepth;
        float chorusRate;
        float chorusMix;

        // Phaser
        float phaserDepth;
        float phaserRate;
        float phaserFeedback;
        float phaserMix;

        // Preset
        int presetIndex;

        float<harmonics> getDecay (float note)
        {
            // Adjusted decay for natural Rhodes sustain characteristics
            // Original decays: 50% at 700ms, 25% at 1750ms, 10% at 3700ms
            float baseDecayRate = (this.decayRate / 25000.0f);  // Increased from 40000 for faster decay
            float harmonicScaling = 1.0f - (this.harmonicDecayRate / 150000.0f);  // Increased from 200000 for faster harmonic decay

            float scalingMultiplier = (48.0f - note) / 12.0f;
            float keyScalingFactor = scalingMultiplier * (this.keyScaling * 0.02f);

            if (keyScalingFactor > 0)
                baseDecayRate = 1.0f - (baseDecayRate / (1.0f + keyScalingFactor));
            else
                baseDecayRate = 1.0f - (baseDecayRate * (1.0f - keyScalingFactor));

            float<harmonics> decay;
            float scaling = 1.0f;

            for (wrap<harmonics> i)
            {
                decay[i] = baseDecayRate * scaling;
                scaling *= harmonicScaling;
            }

            return decay;
        }

        float<harmonics> getRelease (float note)
        {
            return 0.999f - (this.releaseRate / 1000.0f);
        }

        float<Instrument::harmonics> getInitialAmplitudes (float note, float  velocity)
        {
            // Based on spectral analysis of "Mark II fff_c37f0000.wav":
            // The Rhodes Mark II has exceptionally strong EVEN harmonics
            // - 4th harmonic is STRONGEST (53.6x fundamental!)
            // - 6th harmonic: 23.1x, 8th: 20.8x, 2nd: 15.7x, 10th: 15.5x
            // - This extreme harmonic content creates the characteristic Rhodes "bell" sound
            //
            // The tine vibration produces strong even harmonics due to:
            // 1. Asymmetric pickup position
            // 2. Non-linear magnetic interaction
            // 3. Tine resonance modes
            let velocity100 = float<Instrument::harmonics> (
                0.100f,   // H1:  Fundamental (normalized reference)
                1.570f,   // H2:  15.7x - strong even harmonic
                0.060f,   // H3:  0.6x  - odd harmonics weaker
                5.357f,   // H4:  53.6x - STRONGEST! Characteristic Rhodes
                0.072f,   // H5:  0.7x
                2.315f,   // H6:  23.1x - very strong
                0.069f,   // H7:  0.7x
                2.085f,   // H8:  20.8x - very strong
                0.070f,   // H9:  0.7x
                1.545f,   // H10: 15.5x - strong
                0.037f,   // H11: 0.4x
                0.492f,   // H12: 4.9x
                0.047f,   // H13: 0.5x
                0.939f,   // H14: 9.4x
                0.023f,   // H15: 0.2x
                0.055f,   // H16: 0.5x
                0.020f,   // H17
                0.040f,   // H18
                0.018f,   // H19
                0.035f,   // H20
                0.015f,   // H21
                0.030f,   // H22
                0.012f,   // H23
                0.025f,   // H24
                0.010f,   // H25
                0.020f,   // H26
                0.008f,   // H27
                0.015f,   // H28
                0.006f,   // H29
                0.010f,   // H30
                0.004f,   // H31
                0.005f    // H32
            );

            let velocity0 = float<Instrument::harmonics> (
                0.015f, 0.235f, 0.009f, 0.804f, 0.011f, 0.347f, 0.010f, 0.313f,
                0.011f, 0.232f, 0.006f, 0.074f, 0.007f, 0.141f, 0.003f, 0.008f,
                0.003f, 0.006f, 0.003f, 0.005f, 0.002f, 0.005f, 0.002f, 0.004f,
                0.002f, 0.003f, 0.001f, 0.002f, 0.001f, 0.002f, 0.001f, 0.001f
            );

            // Softer velocity curve to prevent harsh attacks
            // Compress high velocities using power curve
            float adjustedVelocity = pow(velocity, 0.85f);  // Increased from 0.75 for more dynamic range
            
            var v = (velocity100 * adjustedVelocity) + (velocity0 * (1.0f - adjustedVelocity));

            // Much gentler brightness scaling due to strong natural harmonics
            // Original had too much brightness boost
            float brightnessScaling = -0.35f + (0.45f * (this.brightness * 0.01f));

            brightnessScaling += (adjustedVelocity * this.velocityScaling * 0.01f * 0.25f);

            for (wrap<harmonics> i)
                v[i] *= (1.0f + brightnessScaling * float (i));

            return v;
        }
    }

    Params createParams()
    {
        Params p;

        p.decayRate = 10;
        p.releaseRate = 20;
        p.keyScaling = 50;
        p.harmonicDecayRate = 20;

        return p;
    }


    processor ParamsProcessor
    {
        // --- Preset-Struct Input (muss bei den Endpoints ganz oben stehen) ---
        input event Instrument::Params paramsIn;

        // --- Preset ---
        input event int presetIndex [[ name: "Preset", min: 0, max: 3, init: 0 ]];

        // --- Basis-Parameter ---
        input event float brightness        [[ name: "Brightness",          min: 0.0, max: 100.0, init: 30, unit: "%" ]];
        input event float velocityScaling   [[ name: "Velocity Scaling",    min: 0.0, max: 100.0, init: 50, unit: "%" ]];
        input event float decayRate         [[ name: "Decay Rate",          min: 0.0, max: 100.0, init: 10, unit: "%" ]];
        input event float harmonicDecayRate [[ name: "Harmonic Decay Rate", min: 0.0, max: 100.0, init: 30, unit: "%" ]];
        input event float keyScaling        [[ name: "Key Scaling",         min: 0.0, max: 100.0, init: 50, unit: "%" ]];
        input event float releaseRate       [[ name: "Release Rate",        min: 0.0, max: 100.0, init: 60, unit: "%" ]];
        input event float vibratoDepth      [[ name: "Vibrato Intensity",   min: 0.0, max: 100.0, init: 25, unit: "%" ]];
        input event float vibratoRate       [[ name: "Vibrato Speed",       min: 0.0, max: 100.0, init: 50, unit: "%" ]];

        // --- Pickup ---
        input event int   pickupType        [[ name: "Pickup Type",         min: 0, max: 1, init: 0 ]];
        input event float pickupSymmetry    [[ name: "Pickup Symmetry",     min: -1.0, max: 1.0, init: 0.0 ]];
        input event float pickupDistance    [[ name: "Pickup Distance",     min: 0.0, max: 1.0, init: 0.5 ]];
        input event float pickupInputGain   [[ name: "Pickup Input Gain",   min: 0.0, max: 2.0, init: 1.0 ]];
        input event float pickupOutputGain  [[ name: "Pickup Output Gain",  min: 0.0, max: 2.0, init: 1.0 ]];
        input event float pickupNonlinearity[[ name: "Pickup Nonlinearity", min: 0.0, max: 100.0, init: 30, unit: "%" ]];
        input event float pickupBarkAmount  [[ name: "Pickup Bark Amount",  min: 0.0, max: 100.0, init: 20, unit: "%" ]];

        // --- Hammer ---
        input event float hammerStiffness   [[ name: "Hammer Stiffness",    min: 0.0, max: 100.0, init: 50, unit: "%" ]];
        input event float hammerStrength    [[ name: "Hammer Strength",     min: 0.0, max: 100.0, init: 50, unit: "%" ]];
        input event float hammerNoise       [[ name: "Hammer Noise",        min: 0.0, max: 100.0, init: 10, unit: "%" ]];

        // --- Fork ---
        input event float forkDecay         [[ name: "Fork Decay",          min: 0.0, max: 100.0, init: 50, unit: "%" ]];
        input event float forkVolume        [[ name: "Fork Volume",         min: 0.0, max: 100.0, init: 50, unit: "%" ]];
        input event float forkToneColor     [[ name: "Fork Tone",           min: 0.0, max: 100.0, init: 50, unit: "%" ]];
        input event float forkRingTime      [[ name: "Fork RingTime",       min: 0.0, max: 100.0, init: 50, unit: "%" ]];
        input event float forkResonance     [[ name: "Fork Resonance",      min: 0.0, max: 100.0, init: 40, unit: "%" ]];

        // --- Damper ---
        input event float damperTone        [[ name: "Damper Tone",         min: 0.0, max: 100.0, init: 50, unit: "%" ]];
        input event float damperAttack      [[ name: "Damper Attack",       min: 0.0, max: 100.0, init: 20, unit: "%" ]];
        input event float damperRelease     [[ name: "Damper Release",      min: 0.0, max: 100.0, init: 20, unit: "%" ]];
        input event float damperLevel       [[ name: "Damper Level",        min: 0.0, max: 100.0, init: 30, unit: "%" ]];

        // --- Chorus ---
        input event float chorusDepth       [[ name: "Chorus Depth",        min: 0.0, max: 100.0, init: 40, unit: "%" ]];
        input event float chorusRate        [[ name: "Chorus Rate",         min: 0.0, max: 100.0, init: 50, unit: "%" ]];
        input event float chorusMix         [[ name: "Chorus Mix",          min: 0.0, max: 100.0, init: 30, unit: "%" ]];

        // --- Phaser ---
        input event float phaserDepth       [[ name: "Phaser Depth",        min: 0.0, max: 100.0, init: 50, unit: "%" ]];
        input event float phaserRate        [[ name: "Phaser Rate",         min: 0.0, max: 100.0, init: 40, unit: "%" ]];
        input event float phaserFeedback    [[ name: "Phaser Feedback",     min: 0.0, max: 100.0, init: 30, unit: "%" ]];
        input event float phaserMix         [[ name: "Phaser Mix",          min: 0.0, max: 100.0, init: 0, unit: "%" ]];

        // --- Output ---
        output event Instrument::Params paramsOut;

        // --- Interner Zustand ---
        Instrument::Params params = createParams();

        // --- Preset-Handler ---
        event presetIndex (int i)
        {
            params.presetIndex = i;

            if (i == 0) // Rhodes
            {
                params.brightness        = 40.0f;  // Reduced - harmonics are now naturally stronger
                params.velocityScaling   = 50.0f;  // Reduced for more natural dynamics
                params.decayRate         = 18.0f;  // Increased for proper decay to match original
                params.harmonicDecayRate = 35.0f;  // Increased - higher harmonics should decay faster
                params.keyScaling        = 40.0f;
                params.releaseRate       = 50.0f;
                params.vibratoDepth      = 15.0f;
                params.vibratoRate       = 40.0f;

                params.pickupType        = 0;
                params.pickupSymmetry    = 0.0f;
                params.pickupDistance    = 0.4f;
                params.pickupInputGain   = 0.8f;   // Reduced further
                params.pickupOutputGain  = 1.0f;   // Reduced
                params.pickupNonlinearity= 20.0f;  // Reduced
                params.pickupBarkAmount  = 15.0f;  // Reduced

                params.hammerStiffness   = 40.0f;  // Reduced
                params.hammerStrength    = 40.0f;  // Reduced
                params.hammerNoise       = 5.0f;   // Reduced

                params.forkDecay         = 50.0f;
                params.forkVolume        = 55.0f;  // Reduced
                params.forkToneColor     = 40.0f;
                params.forkRingTime      = 30.0f;
                params.forkResonance     = 40.0f;  // Reduced

                params.damperTone        = 50.0f;
                params.damperAttack      = 20.0f;
                params.damperRelease     = 25.0f;
                params.damperLevel       = 30.0f;

                params.chorusDepth       = 35.0f;
                params.chorusRate        = 45.0f;
                params.chorusMix         = 25.0f;

                params.phaserDepth       = 40.0f;
                params.phaserRate        = 35.0f;
                params.phaserFeedback    = 25.0f;
                params.phaserMix         = 0.0f;
            }
            if (i == 1) // Wurlitzer
            {
                params.brightness        = 45.0f;
                params.velocityScaling   = 60.0f;
                params.decayRate         = 20.0f;
                params.harmonicDecayRate = 30.0f;
                params.keyScaling        = 50.0f;
                params.releaseRate       = 65.0f;
                params.vibratoDepth      = 20.0f;
                params.vibratoRate       = 35.0f;

                params.pickupType        = 0;
                params.pickupSymmetry    = 0.2f;
                params.pickupDistance    = 0.6f;
                params.pickupInputGain   = 1.2f;
                params.pickupOutputGain  = 1.0f;
                params.pickupNonlinearity= 40.0f;
                params.pickupBarkAmount  = 15.0f;

                params.hammerStiffness   = 70.0f;
                params.hammerStrength    = 60.0f;
                params.hammerNoise       = 15.0f;

                params.forkDecay         = 55.0f;
                params.forkVolume        = 55.0f;
                params.forkToneColor     = 60.0f;
                params.forkRingTime      = 40.0f;
                params.forkResonance     = 35.0f;

                params.damperTone        = 60.0f;
                params.damperAttack      = 25.0f;
                params.damperRelease     = 30.0f;
                params.damperLevel       = 35.0f;

                params.chorusDepth       = 30.0f;
                params.chorusRate        = 40.0f;
                params.chorusMix         = 20.0f;

                params.phaserDepth       = 35.0f;
                params.phaserRate        = 30.0f;
                params.phaserFeedback    = 20.0f;
                params.phaserMix         = 0.0f;
            }
            if (i == 2) // Ambient
            {
                params.brightness        = 50.0f;
                params.velocityScaling   = 50.0f;
                params.decayRate         = 40.0f;
                params.harmonicDecayRate = 50.0f;
                params.keyScaling        = 20.0f;
                params.releaseRate       = 90.0f;
                params.vibratoDepth      = 30.0f;
                params.vibratoRate       = 20.0f;

                params.pickupType        = 0;
                params.pickupSymmetry    = -0.1f;
                params.pickupDistance    = 0.3f;
                params.pickupInputGain   = 0.8f;
                params.pickupOutputGain  = 1.0f;
                params.pickupNonlinearity= 25.0f;
                params.pickupBarkAmount  = 10.0f;

                params.hammerStiffness   = 40.0f;
                params.hammerStrength    = 30.0f;
                params.hammerNoise       = 5.0f;

                params.forkDecay         = 70.0f;
                params.forkVolume        = 70.0f;
                params.forkToneColor     = 50.0f;
                params.forkRingTime      = 60.0f;
                params.forkResonance     = 55.0f;

                params.damperTone        = 40.0f;
                params.damperAttack      = 10.0f;
                params.damperRelease     = 20.0f;
                params.damperLevel       = 20.0f;

                params.chorusDepth       = 50.0f;
                params.chorusRate        = 30.0f;
                params.chorusMix         = 40.0f;

                params.phaserDepth       = 60.0f;
                params.phaserRate        = 25.0f;
                params.phaserFeedback    = 40.0f;
                params.phaserMix         = 30.0f;
            }
            if (i == 3) // Chorus EP
            {
                params.brightness        = 65.0f;
                params.velocityScaling   = 55.0f;
                params.decayRate         = 25.0f;
                params.harmonicDecayRate = 30.0f;
                params.keyScaling        = 50.0f;
                params.releaseRate       = 60.0f;
                params.vibratoDepth      = 40.0f;
                params.vibratoRate       = 60.0f;

                params.pickupType        = 0;
                params.pickupSymmetry    = 0.0f;
                params.pickupDistance    = 0.5f;
                params.pickupInputGain   = 1.0f;
                params.pickupOutputGain  = 1.0f;
                params.pickupNonlinearity= 30.0f;
                params.pickupBarkAmount  = 20.0f;

                params.hammerStiffness   = 55.0f;
                params.hammerStrength    = 50.0f;
                params.hammerNoise       = 12.0f;

                params.forkDecay         = 60.0f;
                params.forkVolume        = 65.0f;
                params.forkToneColor     = 55.0f;
                params.forkRingTime      = 45.0f;
                params.forkResonance     = 50.0f;

                params.damperTone        = 55.0f;
                params.damperAttack      = 20.0f;
                params.damperRelease     = 25.0f;
                params.damperLevel       = 25.0f;

                params.chorusDepth       = 60.0f;
                params.chorusRate        = 55.0f;
                params.chorusMix         = 50.0f;

                params.phaserDepth       = 45.0f;
                params.phaserRate        = 40.0f;
                params.phaserFeedback    = 30.0f;
                params.phaserMix         = 20.0f;
            }

            paramsOut <- params;
        }

        // --- Event-Handler für Einzelparameter ---
        event brightness        (float f) { params.brightness        = f; paramsOut <- params; }
        event velocityScaling   (float f) { params.velocityScaling   = f; paramsOut <- params; }
        event decayRate         (float f) { params.decayRate         = f; paramsOut <- params; }
        event harmonicDecayRate (float f) { params.harmonicDecayRate = f; paramsOut <- params; }
        event keyScaling        (float f) { params.keyScaling        = f; paramsOut <- params; }
        event releaseRate       (float f) { params.releaseRate       = f; paramsOut <- params; }
        event vibratoDepth      (float f) { params.vibratoDepth      = f; paramsOut <- params; }
        event vibratoRate       (float f) { params.vibratoRate       = f; paramsOut <- params; }

        event pickupType        (int i)   { params.pickupType       = i; paramsOut <- params; }
        event pickupSymmetry    (float f) { params.pickupSymmetry   = f; paramsOut <- params; }
        event pickupDistance    (float f) { params.pickupDistance   = f; paramsOut <- params; }
        event pickupInputGain   (float f) { params.pickupInputGain  = f; paramsOut <- params; }
        event pickupOutputGain  (float f) { params.pickupOutputGain = f; paramsOut <- params; }
        event pickupNonlinearity(float f) { params.pickupNonlinearity=f; paramsOut <- params; }
        event pickupBarkAmount  (float f) { params.pickupBarkAmount = f; paramsOut <- params; }

        event hammerStiffness   (float f) { params.hammerStiffness  = f; paramsOut <- params; }
        event hammerStrength    (float f) { params.hammerStrength   = f; paramsOut <- params; }
        event hammerNoise       (float f) { params.hammerNoise      = f; paramsOut <- params; }

        event forkDecay         (float f) { params.forkDecay        = f; paramsOut <- params; }
        event forkVolume        (float f) { params.forkVolume       = f; paramsOut <- params; }
        event forkToneColor     (float f) { params.forkToneColor    = f; paramsOut <- params; }
        event forkRingTime      (float f) { params.forkRingTime     = f; paramsOut <- params; }
        event forkResonance     (float f) { params.forkResonance    = f; paramsOut <- params; }

        event damperTone        (float f) { params.damperTone       = f; paramsOut <- params; }
        event damperAttack      (float f) { params.damperAttack     = f; paramsOut <- params; }
        event damperRelease     (float f) { params.damperRelease    = f; paramsOut <- params; }
        event damperLevel       (float f) { params.damperLevel      = f; paramsOut <- params; }

        event chorusDepth       (float f) { params.chorusDepth      = f; paramsOut <- params; }
        event chorusRate        (float f) { params.chorusRate       = f; paramsOut <- params; }
        event chorusMix         (float f) { params.chorusMix        = f; paramsOut <- params; }

        event phaserDepth       (float f) { params.phaserDepth      = f; paramsOut <- params; }
        event phaserRate        (float f) { params.phaserRate       = f; paramsOut <- params; }
        event phaserFeedback    (float f) { params.phaserFeedback   = f; paramsOut <- params; }
        event phaserMix         (float f) { params.phaserMix        = f; paramsOut <- params; }
    }
}

//==============================================================================
graph Voice
{
    input event Instrument::Params paramsIn;
    input event (std::notes::NoteOn, std::notes::NoteOff) eventsIn;

    output stream float audioOut;

    node
    {
        osc = OscillatorBank (Instrument::harmonics);
        amplitudeSource = AmplitudeSource;
    }

    connection
    {
        paramsIn  -> osc.paramsIn, amplitudeSource.paramsIn;
        eventsIn  -> osc.eventsIn, amplitudeSource.eventsIn;

        amplitudeSource.out -> osc.amplitudes;
        osc.audioOut        -> audioOut;
    }
}

//==============================================================================
processor OscillatorBank (int size = 64)
{
    input event (std::notes::NoteOn) eventsIn;
    input event Instrument::Params paramsIn;
    input stream float<size> amplitudes;

    output stream float audioOut;

    event paramsIn (Instrument::Params p)
    {
        params = p;
    }

    event eventsIn (std::notes::NoteOn e)
    {
        notePitch = e.pitch;
        oscillators = 1.0f;
        setMultipliers();
    }

    Instrument::Params params;

    float<Instrument::harmonics> decay, release;
    float notePitch;

    void setMultipliers()
    {
        let noteFrequency = std::notes::noteToFrequency (notePitch);
        let nyquist = float (processor.frequency / 2.0);

        for (wrap<size> i)
        {
            let harmonicFrequency = noteFrequency * (int (i) + 1);

            if (harmonicFrequency < nyquist)
            {
                let angle = float32 (twoPi * harmonicFrequency * processor.period);
                multiplier[i].real = cos (angle);
                multiplier[i].imag = sin (angle);
            }
            else
            {
                multiplier[i] = 1.0f;
            }
        }
    }

    complex32<size> oscillators = 1.0f,
                    multiplier = 1.0f;

    void main()
    {
        loop
        {
            oscillators = oscillators * multiplier;

            if const (size == 1)
                audioOut <- oscillators.imag * amplitudes;
            else
                audioOut <- sum (oscillators.imag * amplitudes);

            advance();
        }
    }
}

//==============================================================================
processor AmplitudeSource
{
    input event (std::notes::NoteOn, std::notes::NoteOff) eventsIn;
    input event Instrument::Params paramsIn;

    output stream float<Instrument::harmonics> out;

    Instrument::Params params;
    let interpolatedSteps = 64;
    
    // Attack envelope constants
    let attackRate = 0.065f;        // Exponential rate: reaches 99.9% in ~106 samples (~2.4ms)
    let attackCompleteThreshold = 0.999f;
    
    // Soft saturation constants
    let saturationThreshold = 0.7f;
    let saturationHeadroom = 1.0f - saturationThreshold;
    
    float<Instrument::harmonics> currentValue, release, decay;
    bool released = false;
    
    // Attack envelope to prevent harsh transients
    // Based on analysis: Rhodes attack reaches peak in ~2.4ms
    float attackEnvelope = 0.0f;
    float attackTarget = 1.0f;
    bool inAttack = false;

    event paramsIn (Instrument::Params p)
    {
        params = p;
    }

    event eventsIn (std::notes::NoteOn e)
    {
        release      = params.getRelease (e.pitch);
        decay        = params.getDecay (e.pitch);
        currentValue = params.getInitialAmplitudes (e.pitch, e.velocity);
        released     = false;
        
        // Start fast attack envelope (2-3ms to peak based on WAV analysis)
        attackEnvelope = 0.0f;
        attackTarget = 1.0f;
        inAttack = true;
    }

    event eventsIn (std::notes::NoteOff e)
    {
        released = true;
        inAttack = false;
    }

    void main()
    {
        loop
        {
            // Fast attack envelope to smooth note onset (prevents clicks/harshness)
            // Target: 2.4ms attack at 44.1kHz = ~106 samples
            // Using 1-pole exponential: reaches 63% in ~15 samples with rate 0.065
            // Reaches 99% in ~70 samples (~1.6ms), 99.9% in ~106 samples (~2.4ms)
            if (inAttack && attackEnvelope < attackTarget)
            {
                attackEnvelope += (attackTarget - attackEnvelope) * attackRate;
                
                if (attackEnvelope > attackCompleteThreshold)
                {
                    attackEnvelope = 1.0f;
                    inAttack = false;
                }
            }
            
            let target = currentValue * (released ? release : decay);
            let increment = (target - currentValue) / interpolatedSteps;

            loop (interpolatedSteps)
            {
                // Apply attack envelope to smooth the onset
                float<Instrument::harmonics> envelopedValue = currentValue * attackEnvelope;
                
                // Apply overall scaling to compensate for stronger harmonics
                // Original had weaker harmonics, current has much stronger (esp. H4=53x)
                // Scale down to prevent clipping and match original amplitude
                envelopedValue = envelopedValue * 0.12f;  // Compensate for ~8x stronger harmonic content
                
                // Soft saturation to prevent harshness
                // Apply gentle compression similar to tube amp
                for (wrap<Instrument::harmonics> i)
                {
                    float sample = envelopedValue[i];
                    // Soft clipping with smooth tanh curve
                    if (abs(sample) > saturationThreshold)
                    {
                        float excess = (abs(sample) - saturationThreshold) / saturationHeadroom;
                        // tanh provides smooth compression: linear near 0, approaches 1 asymptotically
                        float compressed = saturationThreshold + saturationHeadroom * tanh(excess);
                        sample = compressed * sign(sample);
                        envelopedValue[i] = sample;
                    }
                }
                
                out <- envelopedValue;
                currentValue += increment;
                advance();
            }
        }
    }
    
    float sign(float val)
    {
        if (val > 0.0f) return 1.0f;
        if (val < 0.0f) return -1.0f;
        return 0.0f;
    }
}

//==============================================================================
// PickupModel: Enhanced with nonlinear interactions and "bark" effect
//==============================================================================

processor PickupModel
{
    input  stream float32 in;
    output stream float32 out;

    // Event‑Input für Instrument‑Parameter
    input event Instrument::Params paramsIn;

    // interne Variablen
    Instrument::Params params;
    int     type   = 0;
    float32 sym    = 0.0f;
    float32 dist   = 0.5f;
    float32 inGain = 1.0f;
    float32 outGain= 1.0f;
    float32 nonlin = 0.3f;
    float32 bark   = 0.2f;

    // State für Resonanzketten und "Bark"-Effekt
    float32 resonanceState = 0.0f;
    float32 prevSample = 0.0f;

    // Event‑Handler: übernimmt Werte aus dem Struct
    event paramsIn (Instrument::Params p)
    {
        params  = p;

        type    = p.pickupType;
        sym     = p.pickupSymmetry;
        dist    = p.pickupDistance;
        inGain  = p.pickupInputGain;
        outGain = p.pickupOutputGain;
        nonlin  = p.pickupNonlinearity * 0.01f;  // 30% init -> 0.3
        bark    = p.pickupBarkAmount * 0.01f;    // 20% init -> 0.2
    }

    void main()
    {
        loop
        {
            float32 x = in * inGain;

            // Asymmetrische Pickup-Position (typisch für Rhodes)
            if (type == 0)
            {
                // Elektromagnetisch mit Asymmetrie
                x = x * (1.0f + sym * 0.15f);
                
                // Nichtlineare Interaktion zwischen Zunge und Pickup
                // REDUCED scaling for softer sound (was causing harsh sawtooth)
                let nonlinearScaling = 0.12f;  // Reduced from 0.3f
                float32 squared = x * x;
                x = x + (squared * sign(x) * nonlin * nonlinearScaling);
                
                // Pickup-Distanz beeinflusst Amplitude und Obertöne
                x = x * (1.0f - dist * 0.2f);
                
                // "Bark"-Effekt: Resonanz und leichte Übersteuerung
                // REDUCED for softer sound
                float32 derivative = x - prevSample;
                resonanceState = resonanceState * 0.99f + derivative * bark * 0.3f; // Increased decay, reduced drive
                
                // Soft clipping für den typischen Rhodes "Growl"
                // REDUCED to prevent harsh sawtooth distortion
                float32 barkContribution = resonanceState * (1.0f + abs(x) * 0.3f); // Reduced from 0.5f
                x = x + barkContribution * 0.7f; // Additional attenuation
                
                // Sanfte Übersteuerung (typisch für Vintage Rhodes Amps)
                // GENTLER saturation curve
                if (bark > 0.01f)
                {
                    let ampDriveGain = 1.05f;      // Reduced from 1.2f
                    let ampOutputScale = 0.95f;    // Increased from 0.9f
                    float32 driven = x * (1.0f + bark * 0.3f); // Reduced from 0.5f
                    x = tanh(driven * ampDriveGain) * ampOutputScale;
                }
            }
            else
            {
                // Elektrostatisch (Wurlitzer-Style)
                x = x * (1.0f + sym * 0.25f);
                
                // Wurlitzer hat stärkere Nichtlinearität
                x = tanh(x * (1.0f + nonlin * 0.8f));
                
                // Distanzabhängige Dämpfung
                x = x * (1.0f - dist * 0.4f);
                
                // Wurlitzer "Reed Bark" - anders als Rhodes
                float32 derivative = x - prevSample;
                resonanceState = resonanceState * 0.96f + derivative * bark * 0.4f;
                x = x + resonanceState * 0.7f;
            }

            prevSample = x;
            out <- x * outGain;
            advance();
        }
    }

    float32 sign(float32 val)
    {
        if (val > 0.0f) return 1.0f;
        if (val < 0.0f) return -1.0f;
        return 0.0f;
    }
}

processor HammerModel
{
    input  stream float32 in;
    output stream float32 out;

    input event Instrument::Params paramsIn;
    input event (std::notes::NoteOn) noteEvents; // nur NoteOn nötig

    Instrument::Params params;
    float32 stiff = 0.5f;
    float32 str   = 0.5f;
    float32 noi   = 0.1f;

    std::random::RNG rng;
    float32 noiseEnv = 0.0f;

    event paramsIn (Instrument::Params p)
    {
        params = p;
        stiff  = p.hammerStiffness * 0.01f;
        str    = p.hammerStrength  * 0.01f;
        noi    = p.hammerNoise     * 0.01f;
    }

    event noteEvents (std::notes::NoteOn e)
    {
        // Trigger Noise-Burst bei Anschlag
        noiseEnv = 1.0f;
    }

    void main()
    {
        rng.seed(12345);
        
        let hammerSaturationScale = 0.9f; // Saturation curve scaling

        loop
        {
            float32 x = in;

            // Härte - REDUCED for softer attack
            x = x * (1.0f + stiff * 0.3f); // Reduced from 0.5f
            
            // Gentler saturation curve
            x = tanh(x * hammerSaturationScale) / hammerSaturationScale;

            // Stärke - more moderate scaling
            x = x * (0.6f + str * 0.3f); // Reduced range from (0.5f + str)

            // Noise nur wenn NoiseEnv > 0
            // REDUCED noise amplitude to prevent harshness
            if (noiseEnv > 0.001f)
            {
                float32 burst = rng.getBipolar() * noi * noiseEnv * 0.05f; // Reduced from 0.1f
                x += burst;
                noiseEnv *= 0.97f; // Faster decay from 0.95f
            }

            out <- x;
            advance();
        }
    }
}

processor ForkModel
{
    input  stream float32 in;
    output stream float32 out;

    input event Instrument::Params paramsIn;

    Instrument::Params params;
    float32 decay = 0.5f;
    float32 vol   = 0.5f;
    float32 tone  = 0.5f;
    float32 ring  = 0.5f;
    float32 reso  = 0.4f;

    // States für komplexe Resonanz (simuliert Zungen-Resonanzen)
    float32 state = 0.0f;
    float32 resonance1 = 0.0f;
    float32 resonance2 = 0.0f;
    float32 resonance3 = 0.0f;

    event paramsIn (Instrument::Params p)
    {
        params = p;
        decay  = p.forkDecay     * 0.01f;
        vol    = p.forkVolume    * 0.01f;
        tone   = p.forkToneColor * 0.01f;
        ring   = p.forkRingTime  * 0.01f;
        reso   = p.forkResonance * 0.01f;
    }

    void main()
    {
        loop
        {
            float32 x = in;

            // Decay mit nichtlinearem Verhalten
            state = state * (1.0f - decay * 0.01f) + x;
            
            // Mehrfache Resonanzketten (simuliert verschiedene Zungen-Modi)
            // Diese erzeugen die komplexen Obertöne eines echten E-Pianos
            resonance1 = resonance1 * (0.995f - reso * 0.05f) + state * reso * 0.3f;
            resonance2 = resonance2 * (0.990f - reso * 0.08f) + state * reso * 0.2f;
            resonance3 = resonance3 * (0.985f - reso * 0.10f) + state * reso * 0.1f;

            // Kombiniere Hauptsignal mit Resonanzen
            x = state + resonance1 + resonance2 * 0.7f + resonance3 * 0.5f;

            // Nichtlineare Interaktion bei hohen Amplituden (typisch für E-Piano)
            if (abs(x) > 0.5f)
            {
                float32 excess = abs(x) - 0.5f;
                x = x - sign(x) * excess * reso * 0.3f;
            }

            // Lautstärke
            x = x * (0.5f + vol);

            // Klangfarbe mit verbesserter Filterung
            float32 low  = x * (1.0f - tone);
            float32 high = tanh(x * 1.5f) * tone;
            x = low + high;

            // RingTime - beeinflusst Nachhall und Sustain
            x = x + state * ring * 0.05f;

            out <- x;
            advance();
        }
    }

    float32 sign(float32 val)
    {
        if (val > 0.0f) return 1.0f;
        if (val < 0.0f) return -1.0f;
        return 0.0f;
    }
}


processor DamperModel
{
    input  stream float32 in;
    output stream float32 out;

    input event Instrument::Params paramsIn;
    input event (std::notes::NoteOn, std::notes::NoteOff) eventsIn;

    Instrument::Params params;
    float32 tone = 0.5f, lvl = 0.3f;

    std::random::RNG rng;
    float32 noiseEnv = 0.0f;

    event paramsIn (Instrument::Params p)
    {
        params = p;
        tone = p.damperTone * 0.01f;
        lvl  = p.damperLevel* 0.01f;
    }

    event eventsIn (std::notes::NoteOn e)  { noiseEnv = 0.0f; } // kein Noise beim Anschlag
    event eventsIn (std::notes::NoteOff e) { noiseEnv = 1.0f; } // Noise-Burst beim Loslassen

    void main()
    {
        rng.seed(98765);

        loop
        {
            float32 x = in;

            // Klangfarbe
            float32 low  = x * (1.0f - tone);
            float32 high = tanh(x) * tone;
            x = low + high;

            // Noise nur bei Release
            if (noiseEnv > 0.001f)
            {
                float32 burst = rng.getBipolar() * lvl * noiseEnv * 0.1f;
                x += burst;
                noiseEnv *= 0.93f; // Decay
            }

            out <- x;
            advance();
        }
    }
}

processor Tremolo
{
    input stream float32 in;
    output stream float32<2> out;

    input event Instrument::Params paramsIn;

    Instrument::Params params;

    float32 frames  = 10000.0f;
    float32 depth   = 0.0f;
    float32 current = 0.5f;

    event paramsIn (Instrument::Params p)
    {
        params = p;

        // Vibrato-Rate: Anzahl Frames pro Halbwelle
        frames = float32 (processor.frequency) / (1.0f + (p.vibratoRate * 0.1f));

        // Vibrato-Tiefe: Amplitudenabweichung
        depth = p.vibratoDepth * 0.005f;   // etwas feinfühliger Skalierungsfaktor
    }

    void stepTo (float32 target)
    {
        let step = (target - current) / frames;

        loop (int (frames))
        {
            out <- float<2> (in * current, in * (1.0f - current));
            current += step;
            advance();
        }
    }

    void main()
    {
        loop
        {
            stepTo (0.5f + depth);
            stepTo (0.5f - depth);
        }
    }
}

//==============================================================================
// ChorusEffect: Simuliert klassische analoge Chorus-Effekte
//==============================================================================

processor ChorusEffect
{
    input  stream float32 in;
    output stream float32 out;

    input event Instrument:: Params paramsIn;

    Instrument::Params params;
    float32 depth = 0.4f;
    float32 rate  = 0.5f;
    float32 mix   = 0.3f;

    // Delay-Buffer für Chorus (4096 samples = ~93ms bei 44.1kHz)
    // Ausreichend für Chorus-Effekt (typisch 5-25ms Delay)
    float32[4096] delayBuffer;
    wrap<4096> writePos;  // <-- wrap statt int
    
    float32 lfoPhase = 0.0f;
    float32 lfoPhase2 = 0.33f; // Zweiter LFO mit Phasenversatz

    event paramsIn (Instrument::Params p)
    {
        params = p;
        depth = p.chorusDepth * 0.01f;
        rate  = p.chorusRate  * 0.01f;
        mix   = p.chorusMix   * 0.01f;
    }

    void main()
    {
        loop
        {
            float32 x = in;

            // LFO für Delay-Modulation (typische Chorus-Rate:  0.1 - 5 Hz)
            float32 lfoFreq = 0.1f + rate * 4.9f;
            float32 lfoInc = lfoFreq / float32(processor.frequency);
            
            lfoPhase += lfoInc;
            lfoPhase2 += lfoInc;
            if (lfoPhase >= 1.0f) lfoPhase -= 1.0f;
            if (lfoPhase2 >= 1.0f) lfoPhase2 -= 1.0f;

            // Berechne LFO-Werte (Sinuswellen)
            float32 lfo1 = sin(lfoPhase * float32(twoPi));
            float32 lfo2 = sin(lfoPhase2 * float32(twoPi));

            // Delay-Zeit modulieren (5-25ms typisch für Chorus)
            float32 baseDelay = 15.0f * float32(processor.frequency) / 1000.0f; // 15ms
            float32 modDepth = depth * 10.0f * float32(processor. frequency) / 1000.0f; // bis 10ms Modulation
            
            float32 delayTime1 = baseDelay + lfo1 * modDepth;
            float32 delayTime2 = baseDelay + lfo2 * modDepth * 0.8f;

            // Schreibe in Buffer
            delayBuffer[writePos] = x;

            // Lese aus Buffer mit Interpolation (2 Voices)
            float32 readPos1 = float32(int(writePos)) - delayTime1;
            float32 readPos2 = float32(int(writePos)) - delayTime2;
            
            if (readPos1 < 0.0f) readPos1 += 4096.0f;
            if (readPos2 < 0.0f) readPos2 += 4096.0f;

            float32 delayed1 = readDelayLinear(readPos1);
            float32 delayed2 = readDelayLinear(readPos2);

            // Mix: Dry + Wet (zwei leicht verstimmte Kopien)
            float32 wet = (delayed1 + delayed2) * 0.5f;
            float32 mixed = x * (1.0f - mix) + wet * mix;

            writePos++;  // <-- wrap incrementiert automatisch und wrapped bei 4096

            out <- mixed;
            advance();
        }
    }

    float32 readDelayLinear(float32 pos)
    {
        int idx = int(pos);
        float32 frac = pos - float32(idx);
        wrap<4096> idx1 = wrap<4096>(idx);      // <-- wrap verwenden
        wrap<4096> idx2 = wrap<4096>(idx + 1);  // <-- wrap verwenden
        
        return delayBuffer[idx1] * (1.0f - frac) + delayBuffer[idx2] * frac;
    }
}

//==============================================================================
// PhaserEffect: Simuliert klassische analoge Phaser-Effekte
//==============================================================================

processor PhaserEffect
{
    input  stream float32 in;
    output stream float32 out;

    input event Instrument::Params paramsIn;

    Instrument:: Params params;
    float32 depth    = 0.5f;
    float32 rate     = 0.4f;
    float32 feedback = 0.3f;
    float32 mix      = 0.0f;

    // Phaser-State (All-Pass-Filter)
    float32[6] allpassState;
    float32 feedbackState = 0.0f;
    float32 lfoPhase = 0.0f;
    // float32 result = 0.0f;  // <-- ENTFERNEN (nicht verwendet)

    event paramsIn (Instrument::Params p)
    {
        params   = p;
        depth    = p. phaserDepth    * 0.01f;
        rate     = p.phaserRate     * 0.01f;
        feedback = p.phaserFeedback * 0.01f;
        mix      = p.phaserMix      * 0.01f;
    }

    void main()
    {
        loop
        {
            float32 x = in + feedbackState * feedback * 0.5f;

            // LFO für Filter-Modulation (typische Phaser-Rate: 0.05 - 2 Hz)
            float32 lfoFreq = 0.05f + rate * 1.95f;
            float32 lfoInc = lfoFreq / float32(processor.frequency);
            
            lfoPhase += lfoInc;
            if (lfoPhase >= 1.0f) lfoPhase -= 1.0f;

            // LFO-Wert (Sinuswelle)
            float32 lfo = sin(lfoPhase * float32(twoPi));

            // All-Pass-Filter-Koeffizienten modulieren
            // Typischer Phaser verwendet 4-12 All-Pass-Filter in Serie
            float32 minFreq = 200.0f;
            float32 maxFreq = 2000.0f;
            float32 centerFreq = minFreq + (maxFreq - minFreq) * (0.5f + depth * 0.5f * lfo);
            
            // Vereinfachter All-Pass-Koeffizient
            float32 normalizedFreq = centerFreq * float32(twoPi) / float32(processor.frequency);
            float32 coefficient = (normalizedFreq - 1.0f) / (normalizedFreq + 1.0f);

            // Kaskade von All-Pass-Filtern (6 Stages)
            float32 filtered = x;
            
            for (wrap<6> i)  // <-- wrap<6> statt int
            {
                float32 allpassOut = coefficient * filtered + allpassState[i];
                allpassState[i] = filtered - coefficient * allpassOut;
                filtered = allpassOut;
            }

            feedbackState = filtered;

            // Mix Dry/Wet
            float32 mixed = in * (1.0f - mix) + filtered * mix;

            out <- mixed;
            advance();
        }
    }
}