namespace EPMK1
{
    struct Params
    {
        float32 volume;
        float32 tone;
        float32 tineLevel;
        float32 toneBarLevel;
        float32 release;
        float32 hammerLevel;
    }

    Params createDefaultParams()
    {
        Params p;
        p.volume = 0.0f;
        p.tone = 0.0f;
        p.tineLevel = 0.0f;
        p.toneBarLevel = 0.0f;
        p.release = 0.0f;
        p.hammerLevel = -20.0f;
        return p;
    }
}

graph EPMK1  [[ main ]]
{
    input event
    {
        std::midi::Message midiIn;
        EPMK1::Params paramsIn;
    }

    output stream float audioOut0;
    output stream float audioOut1;

    node
    {
        voiceAllocator = std::voices::VoiceAllocator(16);
        voices = EPMK1Voice[16];
        mixer = std::mixers::DynamicSum(float, 16);
        stereoMixer = std::mixers::FixedSum(float, 2);
    }

    connection
    {
        midiIn -> std::midi::MPEConverter -> voiceAllocator;
        paramsIn -> voices.paramsIn;

        voiceAllocator.voiceEventOut -> voices.eventsIn;
        voices.audioOut -> mixer.audioIn;

        mixer.audioOut -> stereoMixer.audioIn[0];
        mixer.audioOut -> stereoMixer.audioIn[1];

        stereoMixer.audioOut -> audioOut0;
        stereoMixer.audioOut -> audioOut1;
    }
}

graph EPMK1Voice
{
    input event
    {
        EPMK1::Params paramsIn;
        std::notes::NoteOn eventsIn;
    }

    output stream float audioOut;

    node
    {
        tine = TineModel;
        toneBar = ToneBarModel;
        hammerNoise = HammerNoise;
        mixer = std::mixers::FixedSum(float, 3);
        toneControl = ToneControl;
        envelope = ADSREnvelope;
        attenuator = std::levels::SmoothedGain(float, 0.1f);
    }

    connection
    {
        paramsIn -> tine.paramsIn,
                    toneBar.paramsIn,
                    hammerNoise.paramsIn,
                    toneControl.paramsIn,
                    envelope.paramsIn,
                    attenuator.paramsIn;

        eventsIn -> tine.eventsIn,
                    toneBar.eventsIn,
                    hammerNoise.eventsIn,
                    envelope.eventsIn;

        tine.audioOut -> mixer.audioIn[0];
        toneBar.audioOut -> mixer.audioIn[1];
        hammerNoise.audioOut -> mixer.audioIn[2];

        mixer.audioOut -> toneControl.audioIn;
        toneControl.audioOut -> envelope.audioIn;
        envelope.audioOut -> attenuator.audioIn;
        attenuator.audioOut -> audioOut;
    }
}

processor ToneControl
{
    input event EPMK1::Params paramsIn;
    input stream float audioIn;
    output stream float audioOut;

    EPMK1::Params params = EPMK1::createDefaultParams();
    float32 lpY1 = 0.0f;
    float32 hpY1 = 0.0f;
    float32 hpX1 = 0.0f;
    float32 lpA = 0.0f;
    float32 lpB = 0.0f;
    float32 hpA = 0.0f;
    float32 hpB = 0.0f;

    event paramsIn (EPMK1::Params p)
    {
        params = p;
        updateFilterCoeffs();
    }

    void updateFilterCoeffs()
    {
        let toneNorm = (params.tone + 50.0f) / 100.0f;
        let lpFreq = 300.0f + toneNorm * 8000.0f;
        let hpFreq = 20.0f + (1.0f - toneNorm) * 200.0f;

        lpB = exp(-float(twoPi) * lpFreq / float(processor.frequency));
        lpA = 1.0f - lpB;

        hpB = exp(-float(twoPi) * hpFreq / float(processor.frequency));
        hpA = 1.0f - hpB;
    }

    void main()
    {
        updateFilterCoeffs();

        loop
        {
            let input = audioIn;

            lpY1 = lpA * input + lpB * lpY1;

            let hpOut = input - hpA * input - hpB * hpY1;
            hpY1 = hpOut;
            hpX1 = input;

            audioOut <- hpOut;

            advance();
        }
    }
}

processor ADSREnvelope
{
    input event EPMK1::Params paramsIn;
    input event std::notes::NoteOn eventsIn;
    input stream float audioIn;
    output stream float audioOut;

    EPMK1::Params params = EPMK1::createDefaultParams();
    float env = 0.0f;
    bool noteActive = false;
    float32 releaseRate = 0.0f;

    event paramsIn (EPMK1::Params p)
    {
        params = p;
        updateReleaseRate();
    }

    event eventsIn (std::notes::NoteOn e)
    {
        if (e.velocity > 0.0f)
        {
            noteActive = true;
            env = 1.0f;
        }
        else
        {
            noteActive = false;
        }
    }

    void updateReleaseRate()
    {
        let releaseNorm = (params.release + 50.0f) / 100.0f;
        let releaseTime = 0.05f + releaseNorm * 5.0f;
        releaseRate = 1.0f / (releaseTime * float(processor.frequency));
    }

    void main()
    {
        updateReleaseRate();

        loop
        {
            if (noteActive)
            {
                env = 1.0f;
            }
            else
            {
                env = max(0.0f, env - releaseRate);
            }

            audioOut <- audioIn * env;

            advance();
        }
    }
}

//==============================================================================
// Tine Model - Two resonators at different ratios
// Velocity curve: exponential (v^1.5) for natural dynamic response
//==============================================================================

processor TineModel
{
    input event EPMK1::Params paramsIn;
    input event std::notes::NoteOn eventsIn;
    output stream float audioOut;

    EPMK1::Params params = EPMK1::createDefaultParams();
    float64 noteFreq = 0.0;
    float64 phase1 = 0.0;
    float64 phase2 = 0.0;
    float32 amp1 = 0.0f;
    float32 amp2 = 0.0f;
    float32 velocity = 0.0f;
    bool noteActive = false;

    event paramsIn (EPMK1::Params p) { params = p; }

    event eventsIn (std::notes::NoteOn e)
    {
        noteFreq = std::notes::noteToFrequency(e.pitch);
        velocity = e.velocity;
        
        // Exponential velocity curve (v^1.5) gives more dynamic range
        // Soft notes (v=0.2): 0.089, Medium (v=0.5): 0.354, Hard (v=1.0): 1.0
        float velCurve = pow(velocity, 1.5f);
        
        amp1 = velCurve;
        amp2 = velCurve;
        
        phase1 = 0.0f;
        phase2 = 0.0f;
        
        noteActive = true;
    }

    void main()
    {
        loop
        {
            if (noteActive && amp1 > 0.0001f)
            {
                let freq1 = noteFreq;
                let freq2 = noteFreq * 4.0;

                phase1 = addModulo2Pi(phase1, float64(twoPi) * freq1 / float64(processor.frequency));
                phase2 = addModulo2Pi(phase2, float64(twoPi) * freq2 / float64(processor.frequency));

                let osc1 = sin(phase1) * amp1;
                let osc2 = sin(phase2) * amp2 * 0.25f;

                let level = pow(10.0f, params.tineLevel / 20.0f);
                audioOut <- (osc1 + osc2) * level;

                amp1 *= 0.9996f;
                amp2 *= 0.998f;
            }
            else
            {
                audioOut <- 0.0f;
                noteActive = false;
            }

            advance();
        }
    }
}

//==============================================================================
// Tone Bar Model
// Velocity curve: exponential (v^1.5) for natural dynamic response
//==============================================================================

processor ToneBarModel
{
    input event EPMK1::Params paramsIn;
    input event std::notes::NoteOn eventsIn;
    output stream float audioOut;

    EPMK1::Params params = EPMK1::createDefaultParams();
    float64 noteFreq = 0.0;
    float64 phase = 0.0;
    float32 amp = 0.0f;
    float32 velocity = 0.0f;
    bool noteActive = false;

    event paramsIn (EPMK1::Params p) { params = p; }

    event eventsIn (std::notes::NoteOn e)
    {
        noteFreq = std::notes::noteToFrequency(e.pitch);
        velocity = e.velocity;
        
        // Exponential velocity curve (v^1.5) gives more dynamic range
        float velCurve = pow(velocity, 1.5f);
        amp = velCurve;
        
        phase = 0.0f;
        noteActive = true;
    }

    void main()
    {
        loop
        {
            if (noteActive && amp > 0.0001f)
            {
                phase = addModulo2Pi(phase, float64(twoPi) * noteFreq / float64(processor.frequency));

                let osc = sin(phase) * amp;

                let level = pow(10.0f, params.toneBarLevel / 20.0f);
                audioOut <- osc * level;

                amp *= 0.9993f;
            }
            else
            {
                audioOut <- 0.0f;
                noteActive = false;
            }

            advance();
        }
    }
}

//==============================================================================
// Hammer Noise
// Enhanced velocity response with increased dynamic range (2x multiplier)
//==============================================================================

processor HammerNoise
{
    input event EPMK1::Params paramsIn;
    input event std::notes::NoteOn eventsIn;
    output stream float audioOut;

    EPMK1::Params params = EPMK1::createDefaultParams();
    std::random::RNG rng;
    float env = 0.0f;
    float attackEnv = 0.0f;
    float velocity = 0.0f;
    float lpY1 = 0.0f;
    float lpA = 0.0f;
    float lpB = 0.0f;
    float decayFactor = 0.92f;

    event paramsIn (EPMK1::Params p) { params = p; }

    event eventsIn (std::notes::NoteOn e)
    {
        velocity = clamp(e.velocity, 0.008f, 1.0f);
        
        // Enhanced velocity formula with 2x multiplier for more dynamic range
        // This makes the difference between soft and hard strikes much more audible
        float midiVel = 1.0f + velocity * 126.0f;
        float normalizedVel = (midiVel - 1.0f) / 126.0f;
        float exponent = (1.0f - normalizedVel) * -4.0f;
        env = pow(2.0f, exponent) * 2.0f;  // 2x multiplier for more dynamic range
        
        // Enhanced attack burst with more pronounced effect
        attackEnv = (velocity > 0.5f) ? (velocity - 0.5f) * 3.0f : 0.0f;
        
        // Velocity-sensitive brightness (more extreme range)
        float lpFreq = 300.0f + velocity * 6000.0f;  // 300 Hz to 6300 Hz
        lpB = exp(-float(twoPi) * lpFreq / float(processor.frequency));
        lpA = 1.0f - lpB;
        
        // More velocity-sensitive decay
        decayFactor = 0.90f + velocity * 0.06f;  // Range: 0.90 to 0.96
        
        lpY1 = 0.0f;
    }

    void main()
    {
        rng.seed(12345);

        loop
        {
            if (env > 0.0001f || attackEnv > 0.0001f)
            {
                float noise = rng.getBipolar();
                
                lpY1 = lpA * noise + lpB * lpY1;
                
                float combinedEnv = env + attackEnv * 0.8f;
                
                float level = pow(10.0f, params.hammerLevel / 20.0f);
                audioOut <- lpY1 * combinedEnv * level;
                
                env *= decayFactor;
                attackEnv *= 0.85f;
            }
            else
            {
                audioOut <- 0.0f;
            }

            advance();
        }
    }
}
